{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HTTPCore Do one thing, and do it well. The HTTP Core package provides a minimal low-level HTTP client, which does one thing only. Sending HTTP requests. It does not provide any high level model abstractions over the API, does not handle redirects, multipart uploads, building authentication headers, transparent HTTP caching, URL parsing, session cookie handling, content or charset decoding, handling JSON, environment based configuration defaults, or any of that Jazz. Some things HTTP Core does do: Sending HTTP requests. Thread-safe / task-safe connection pooling. HTTP(S) proxy & SOCKS proxy support. Supports HTTP/1.1 and HTTP/2. Provides both sync and async interfaces. Async backend support for asyncio and trio . Requirements Python 3.7+ Installation For HTTP/1.1 only support, install with: $ pip install httpcore For HTTP/1.1 and HTTP/2 support, install with: $ pip install httpcore [ http2 ] For SOCKS proxy support, install with: $ pip install httpcore [ socks ] Example Let's check we're able to send HTTP requests: import httpcore response = httpcore . request ( \"GET\" , \"https://www.example.com/\" ) print ( response ) # <Response [200]> print ( response . status ) # 200 print ( response . headers ) # [(b'Accept-Ranges', b'bytes'), (b'Age', b'557328'), (b'Cache-Control', b'max-age=604800'), ...] print ( response . content ) # b'<!doctype html>\\n<html>\\n<head>\\n<title>Example Domain</title>\\n\\n<meta charset=\"utf-8\"/>\\n ...' Ready to get going? Head over to the quickstart documentation .","title":"Introduction"},{"location":"#httpcore","text":"Do one thing, and do it well. The HTTP Core package provides a minimal low-level HTTP client, which does one thing only. Sending HTTP requests. It does not provide any high level model abstractions over the API, does not handle redirects, multipart uploads, building authentication headers, transparent HTTP caching, URL parsing, session cookie handling, content or charset decoding, handling JSON, environment based configuration defaults, or any of that Jazz. Some things HTTP Core does do: Sending HTTP requests. Thread-safe / task-safe connection pooling. HTTP(S) proxy & SOCKS proxy support. Supports HTTP/1.1 and HTTP/2. Provides both sync and async interfaces. Async backend support for asyncio and trio .","title":"HTTPCore"},{"location":"#requirements","text":"Python 3.7+","title":"Requirements"},{"location":"#installation","text":"For HTTP/1.1 only support, install with: $ pip install httpcore For HTTP/1.1 and HTTP/2 support, install with: $ pip install httpcore [ http2 ] For SOCKS proxy support, install with: $ pip install httpcore [ socks ]","title":"Installation"},{"location":"#example","text":"Let's check we're able to send HTTP requests: import httpcore response = httpcore . request ( \"GET\" , \"https://www.example.com/\" ) print ( response ) # <Response [200]> print ( response . status ) # 200 print ( response . headers ) # [(b'Accept-Ranges', b'bytes'), (b'Age', b'557328'), (b'Cache-Control', b'max-age=604800'), ...] print ( response . content ) # b'<!doctype html>\\n<html>\\n<head>\\n<title>Example Domain</title>\\n\\n<meta charset=\"utf-8\"/>\\n ...' Ready to get going? Head over to the quickstart documentation .","title":"Example"},{"location":"async/","text":"Async Support HTTPX offers a standard synchronous API by default, but also gives you the option of an async client if you need it. Async is a concurrency model that is far more efficient than multi-threading, and can provide significant performance benefits and enable the use of long-lived network connections such as WebSockets. If you're working with an async web framework then you'll also want to use an async client for sending outgoing HTTP requests. Launching concurrent async tasks is far more resource efficient than spawning multiple threads. The Python interpreter should be able to comfortably handle switching between over 1000 concurrent tasks, while a sensible number of threads in a thread pool might be to enable around 10 or 20 concurrent threads. API differences When using async support, you need make sure to use an async connection pool class: # The async variation of `httpcore.ConnectionPool` async with httpcore . AsyncConnectionPool () as http : ... Or if connecting via a proxy: # The async variation of `httpcore.HTTPProxy` async with httpcore . AsyncHTTPProxy () as proxy : ... Sending requests Sending requests with the async version of httpcore requires the await keyword: import asyncio import httpcore async def main (): async with httpcore . AsyncConnectionPool () as http : response = await http . request ( \"GET\" , \"https://www.example.com/\" ) asyncio . run ( main ()) When including content in the request, the content must either be bytes or an async iterable yielding bytes. Streaming responses Streaming responses also require a slightly different interface to the sync version: with <pool>.stream(...) as response \u2192 async with <pool>.stream() as response . for chunk in response.iter_stream() \u2192 async for chunk in response.aiter_stream() . response.read() \u2192 await response.aread() . response.close() \u2192 await response.aclose() For example: import asyncio import httpcore async def main (): async with httpcore . AsyncConnectionPool () as http : async with http . stream ( \"GET\" , \"https://www.example.com/\" ) as response : async for chunk in response . aiter_stream (): print ( f \"Downloaded: { chunk } \" ) asyncio . run ( main ()) Pool lifespans When using httpcore in an async environment it is strongly recommended that you instantiate and use connection pools using the context managed style: async with httpcore . AsyncConnectionPool () as http : ... To benefit from connection pooling it is recommended that you instantiate a single connection pool in this style, and pass it around throughout your application. If you do want to use a connection pool without this style then you'll need to ensure that you explicitly close the pool once it is no longer required: try : http = httpcore . AsyncConnectionPool () ... finally : await http . aclose () This is a little different to the threaded context, where it's okay to simply instantiate a globally available connection pool, and then allow Python's garbage collection to deal with closing any connections in the pool, once the __del__ method is called. The reason for this difference is that asynchronous code is not able to run within the context of the synchronous __del__ method, so there is no way for connections to be automatically closed at the point of garbage collection. This can lead to unterminated TCP connections still remaining after the Python interpreter quits. Supported environments HTTPX supports either asyncio or trio as an async environment. It will auto-detect which of those two to use as the backend for socket operations and concurrency primitives. AsyncIO AsyncIO is Python's built-in library for writing concurrent code with the async/await syntax. Let's take a look at sending several outgoing HTTP requests concurrently, using asyncio : import asyncio import httpcore import time async def download ( http , year ): await http . request ( \"GET\" , f \"https://en.wikipedia.org/wiki/ { year } \" ) async def main (): async with httpcore . AsyncConnectionPool () as http : started = time . time () # Here we use `asyncio.gather()` in order to run several tasks concurrently... tasks = [ download ( http , year ) for year in range ( 2000 , 2020 )] await asyncio . gather ( * tasks ) complete = time . time () for connection in http . connections : print ( connection ) print ( \"Complete in %.3f seconds\" % ( complete - started )) asyncio . run ( main ()) Trio Trio is an alternative async library , designed around the the principles of structured concurrency . import httpcore import trio import time async def download ( http , year ): await http . request ( \"GET\" , f \"https://en.wikipedia.org/wiki/ { year } \" ) async def main (): async with httpcore . AsyncConnectionPool () as http : started = time . time () async with trio . open_nursery () as nursery : for year in range ( 2000 , 2020 ): nursery . start_soon ( download , http , year ) complete = time . time () for connection in http . connections : print ( connection ) print ( \"Complete in %.3f seconds\" % ( complete - started )) trio . run ( main ) AnyIO AnyIO is an asynchronous networking and concurrency library that works on top of either asyncio or trio. It blends in with native libraries of your chosen backend (defaults to asyncio). The anyio library is designed around the the principles of structured concurrency , and brings many of the same correctness and usability benefits that Trio provides, while interoperating with existing asyncio libraries. import httpcore import anyio import time async def download ( http , year ): await http . request ( \"GET\" , f \"https://en.wikipedia.org/wiki/ { year } \" ) async def main (): async with httpcore . AsyncConnectionPool () as http : started = time . time () async with anyio . create_task_group () as task_group : for year in range ( 2000 , 2020 ): task_group . start_soon ( download , http , year ) complete = time . time () for connection in http . connections : print ( connection ) print ( \"Complete in %.3f seconds\" % ( complete - started )) anyio . run ( main ) Reference httpcore.AsyncConnectionPool A connection pool for making HTTP requests. connections : List [ httpcore . AsyncConnectionInterface ] property readonly Return a list of the connections currently in the pool. For example: >>> pool . connections [ < AsyncHTTPConnection [ 'https://example.com:443' , HTTP / 1.1 , ACTIVE , Request Count : 6 ] > , < AsyncHTTPConnection [ 'https://example.com:443' , HTTP / 1.1 , IDLE , Request Count : 9 ] > , < AsyncHTTPConnection [ 'http://example.com:80' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , ] __init__ ( self , ssl_context = None , max_connections = 10 , max_keepalive_connections = None , keepalive_expiry = None , http1 = True , http2 = False , retries = 0 , local_address = None , uds = None , network_backend = None ) special A connection pool for making HTTP requests. Parameters: Name Type Description Default ssl_context Optional[ssl.SSLContext] An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used. None max_connections Optional[int] The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. 10 max_keepalive_connections Optional[int] The maximum number of idle HTTP connections that will be maintained in the pool. None keepalive_expiry Optional[float] The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool. None http1 bool A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True. True http2 bool A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False. False retries int The maximum number of retries when trying to establish a connection. 0 local_address Optional[str] Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). None uds Optional[str] Path to a Unix Domain Socket to use instead of TCP sockets. None network_backend Optional[httpcore.backends.base.AsyncNetworkBackend] A backend instance to use for handling network I/O. None aclose ( self ) async Close any connections in the pool. handle_async_request ( self , request ) async Send an HTTP request, and return an HTTP response. This is the core implementation that is called into by .request() or .stream() . response_closed ( self , status ) async This method acts as a callback once the request/response cycle is complete. It is called into from the ConnectionPoolByteStream.aclose() method. httpcore.AsyncHTTPProxy A connection pool that sends requests via an HTTP proxy. __init__ ( self , proxy_url , proxy_auth = None , proxy_headers = None , ssl_context = None , max_connections = 10 , max_keepalive_connections = None , keepalive_expiry = None , http1 = True , http2 = False , retries = 0 , local_address = None , uds = None , network_backend = None ) special A connection pool for making HTTP requests. Parameters: Name Type Description Default proxy_url Union[httpcore.URL, bytes, str] The URL to use when connecting to the proxy server. For example \"http://127.0.0.1:8080/\" . required proxy_auth Optional[Tuple[Union[bytes, str], Union[bytes, str]]] Any proxy authentication as a two-tuple of (username, password). May be either bytes or ascii-only str. None proxy_headers Union[Mapping[Union[bytes, str], Union[bytes, str]], Sequence[Tuple[Union[bytes, str], Union[bytes, str]]]] Any HTTP headers to use for the proxy requests. For example {\"Proxy-Authorization\": \"Basic <username>:<password>\"} . None ssl_context Optional[ssl.SSLContext] An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used. None max_connections Optional[int] The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. 10 max_keepalive_connections Optional[int] The maximum number of idle HTTP connections that will be maintained in the pool. None keepalive_expiry Optional[float] The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool. None http1 bool A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True. True http2 bool A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False. False retries int The maximum number of retries when trying to establish a connection. 0 local_address Optional[str] Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). None uds Optional[str] Path to a Unix Domain Socket to use instead of TCP sockets. None network_backend Optional[httpcore.backends.base.AsyncNetworkBackend] A backend instance to use for handling network I/O. None","title":"Async Support"},{"location":"async/#async-support","text":"HTTPX offers a standard synchronous API by default, but also gives you the option of an async client if you need it. Async is a concurrency model that is far more efficient than multi-threading, and can provide significant performance benefits and enable the use of long-lived network connections such as WebSockets. If you're working with an async web framework then you'll also want to use an async client for sending outgoing HTTP requests. Launching concurrent async tasks is far more resource efficient than spawning multiple threads. The Python interpreter should be able to comfortably handle switching between over 1000 concurrent tasks, while a sensible number of threads in a thread pool might be to enable around 10 or 20 concurrent threads.","title":"Async Support"},{"location":"async/#api-differences","text":"When using async support, you need make sure to use an async connection pool class: # The async variation of `httpcore.ConnectionPool` async with httpcore . AsyncConnectionPool () as http : ... Or if connecting via a proxy: # The async variation of `httpcore.HTTPProxy` async with httpcore . AsyncHTTPProxy () as proxy : ...","title":"API differences"},{"location":"async/#sending-requests","text":"Sending requests with the async version of httpcore requires the await keyword: import asyncio import httpcore async def main (): async with httpcore . AsyncConnectionPool () as http : response = await http . request ( \"GET\" , \"https://www.example.com/\" ) asyncio . run ( main ()) When including content in the request, the content must either be bytes or an async iterable yielding bytes.","title":"Sending requests"},{"location":"async/#streaming-responses","text":"Streaming responses also require a slightly different interface to the sync version: with <pool>.stream(...) as response \u2192 async with <pool>.stream() as response . for chunk in response.iter_stream() \u2192 async for chunk in response.aiter_stream() . response.read() \u2192 await response.aread() . response.close() \u2192 await response.aclose() For example: import asyncio import httpcore async def main (): async with httpcore . AsyncConnectionPool () as http : async with http . stream ( \"GET\" , \"https://www.example.com/\" ) as response : async for chunk in response . aiter_stream (): print ( f \"Downloaded: { chunk } \" ) asyncio . run ( main ())","title":"Streaming responses"},{"location":"async/#pool-lifespans","text":"When using httpcore in an async environment it is strongly recommended that you instantiate and use connection pools using the context managed style: async with httpcore . AsyncConnectionPool () as http : ... To benefit from connection pooling it is recommended that you instantiate a single connection pool in this style, and pass it around throughout your application. If you do want to use a connection pool without this style then you'll need to ensure that you explicitly close the pool once it is no longer required: try : http = httpcore . AsyncConnectionPool () ... finally : await http . aclose () This is a little different to the threaded context, where it's okay to simply instantiate a globally available connection pool, and then allow Python's garbage collection to deal with closing any connections in the pool, once the __del__ method is called. The reason for this difference is that asynchronous code is not able to run within the context of the synchronous __del__ method, so there is no way for connections to be automatically closed at the point of garbage collection. This can lead to unterminated TCP connections still remaining after the Python interpreter quits.","title":"Pool lifespans"},{"location":"async/#supported-environments","text":"HTTPX supports either asyncio or trio as an async environment. It will auto-detect which of those two to use as the backend for socket operations and concurrency primitives.","title":"Supported environments"},{"location":"async/#asyncio","text":"AsyncIO is Python's built-in library for writing concurrent code with the async/await syntax. Let's take a look at sending several outgoing HTTP requests concurrently, using asyncio : import asyncio import httpcore import time async def download ( http , year ): await http . request ( \"GET\" , f \"https://en.wikipedia.org/wiki/ { year } \" ) async def main (): async with httpcore . AsyncConnectionPool () as http : started = time . time () # Here we use `asyncio.gather()` in order to run several tasks concurrently... tasks = [ download ( http , year ) for year in range ( 2000 , 2020 )] await asyncio . gather ( * tasks ) complete = time . time () for connection in http . connections : print ( connection ) print ( \"Complete in %.3f seconds\" % ( complete - started )) asyncio . run ( main ())","title":"AsyncIO"},{"location":"async/#trio","text":"Trio is an alternative async library , designed around the the principles of structured concurrency . import httpcore import trio import time async def download ( http , year ): await http . request ( \"GET\" , f \"https://en.wikipedia.org/wiki/ { year } \" ) async def main (): async with httpcore . AsyncConnectionPool () as http : started = time . time () async with trio . open_nursery () as nursery : for year in range ( 2000 , 2020 ): nursery . start_soon ( download , http , year ) complete = time . time () for connection in http . connections : print ( connection ) print ( \"Complete in %.3f seconds\" % ( complete - started )) trio . run ( main )","title":"Trio"},{"location":"async/#anyio","text":"AnyIO is an asynchronous networking and concurrency library that works on top of either asyncio or trio. It blends in with native libraries of your chosen backend (defaults to asyncio). The anyio library is designed around the the principles of structured concurrency , and brings many of the same correctness and usability benefits that Trio provides, while interoperating with existing asyncio libraries. import httpcore import anyio import time async def download ( http , year ): await http . request ( \"GET\" , f \"https://en.wikipedia.org/wiki/ { year } \" ) async def main (): async with httpcore . AsyncConnectionPool () as http : started = time . time () async with anyio . create_task_group () as task_group : for year in range ( 2000 , 2020 ): task_group . start_soon ( download , http , year ) complete = time . time () for connection in http . connections : print ( connection ) print ( \"Complete in %.3f seconds\" % ( complete - started )) anyio . run ( main )","title":"AnyIO"},{"location":"async/#reference","text":"","title":"Reference"},{"location":"async/#httpcoreasyncconnectionpool","text":"A connection pool for making HTTP requests.","title":"httpcore.AsyncConnectionPool"},{"location":"async/#httpcore.AsyncConnectionPool.connections","text":"Return a list of the connections currently in the pool. For example: >>> pool . connections [ < AsyncHTTPConnection [ 'https://example.com:443' , HTTP / 1.1 , ACTIVE , Request Count : 6 ] > , < AsyncHTTPConnection [ 'https://example.com:443' , HTTP / 1.1 , IDLE , Request Count : 9 ] > , < AsyncHTTPConnection [ 'http://example.com:80' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , ]","title":"connections"},{"location":"async/#httpcore.AsyncConnectionPool.__init__","text":"A connection pool for making HTTP requests. Parameters: Name Type Description Default ssl_context Optional[ssl.SSLContext] An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used. None max_connections Optional[int] The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. 10 max_keepalive_connections Optional[int] The maximum number of idle HTTP connections that will be maintained in the pool. None keepalive_expiry Optional[float] The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool. None http1 bool A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True. True http2 bool A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False. False retries int The maximum number of retries when trying to establish a connection. 0 local_address Optional[str] Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). None uds Optional[str] Path to a Unix Domain Socket to use instead of TCP sockets. None network_backend Optional[httpcore.backends.base.AsyncNetworkBackend] A backend instance to use for handling network I/O. None","title":"__init__()"},{"location":"async/#httpcore.AsyncConnectionPool.aclose","text":"Close any connections in the pool.","title":"aclose()"},{"location":"async/#httpcore.AsyncConnectionPool.handle_async_request","text":"Send an HTTP request, and return an HTTP response. This is the core implementation that is called into by .request() or .stream() .","title":"handle_async_request()"},{"location":"async/#httpcore.AsyncConnectionPool.response_closed","text":"This method acts as a callback once the request/response cycle is complete. It is called into from the ConnectionPoolByteStream.aclose() method.","title":"response_closed()"},{"location":"async/#httpcoreasynchttpproxy","text":"A connection pool that sends requests via an HTTP proxy.","title":"httpcore.AsyncHTTPProxy"},{"location":"async/#httpcore.AsyncHTTPProxy.__init__","text":"A connection pool for making HTTP requests. Parameters: Name Type Description Default proxy_url Union[httpcore.URL, bytes, str] The URL to use when connecting to the proxy server. For example \"http://127.0.0.1:8080/\" . required proxy_auth Optional[Tuple[Union[bytes, str], Union[bytes, str]]] Any proxy authentication as a two-tuple of (username, password). May be either bytes or ascii-only str. None proxy_headers Union[Mapping[Union[bytes, str], Union[bytes, str]], Sequence[Tuple[Union[bytes, str], Union[bytes, str]]]] Any HTTP headers to use for the proxy requests. For example {\"Proxy-Authorization\": \"Basic <username>:<password>\"} . None ssl_context Optional[ssl.SSLContext] An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used. None max_connections Optional[int] The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. 10 max_keepalive_connections Optional[int] The maximum number of idle HTTP connections that will be maintained in the pool. None keepalive_expiry Optional[float] The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool. None http1 bool A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True. True http2 bool A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False. False retries int The maximum number of retries when trying to establish a connection. 0 local_address Optional[str] Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). None uds Optional[str] Path to a Unix Domain Socket to use instead of TCP sockets. None network_backend Optional[httpcore.backends.base.AsyncNetworkBackend] A backend instance to use for handling network I/O. None","title":"__init__()"},{"location":"connection-pools/","text":"Connection Pools While the top-level API provides convenience functions for working with httpcore , in practice you'll almost always want to take advantage of the connection pooling functionality that it provides. To do so, instantiate a pool instance, and use it to send requests: import httpcore http = httpcore . ConnectionPool () r = http . request ( \"GET\" , \"https://www.example.com/\" ) print ( r ) # <Response [200]> Connection pools support the same .request() and .stream() APIs as described in the Quickstart . We can observe the benefits of connection pooling with a simple script like so: import httpcore import time http = httpcore . ConnectionPool () for counter in range ( 5 ): started = time . time () response = http . request ( \"GET\" , \"https://www.example.com/\" ) complete = time . time () print ( response , \"in %.3f seconds\" % ( complete - started )) The output should demonstrate the initial request as being substantially slower than the subsequent requests: <Response [200]> in {0.529} seconds <Response [200]> in {0.096} seconds <Response [200]> in {0.097} seconds <Response [200]> in {0.095} seconds <Response [200]> in {0.098} seconds This is to be expected. Once we've established a connection to \"www.example.com\" we're able to reuse it for following requests. Configuration The connection pool instance is also the main point of configuration. Let's take a look at the various options that it provides: SSL configuration ssl_context : An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used. Pooling configuration max_connections : The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. max_keepalive_connections : The maximum number of idle HTTP connections that will be maintained in the pool. keepalive_expiry : The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool. HTTP version support http1 : A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True . http2 : A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False . Other options retries : The maximum number of retries when trying to establish a connection. local_address : Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). uds : Path to a Unix Domain Socket to use instead of TCP sockets. network_backend : A backend instance to use for handling network I/O. Pool lifespans Because connection pools hold onto network resources, careful developers may want to ensure that instances are properly closed once they are no longer required. Working with a single global instance isn't a bad idea for many use case, since the connection pool will automatically be closed when the __del__ method is called on it: # This is perfectly fine for most purposes. # The connection pool will automatically be closed when it is garbage collected, # or when the Python interpreter exits. http = httpcore . ConnectionPool () However, to be more explicit around the resource usage, we can use the connection pool within a context manager: with httpcore . ConnectionPool () as http : ... Or else close the pool explicitly: http = httpcore . ConnectionPool () try : ... finally : http . close () Thread and task safety Connection pools are designed to be thread-safe. Similarly, when using httpcore in an async context connection pools are task-safe. This means that you can have a single connection pool instance shared by multiple threads. Reference httpcore.ConnectionPool A connection pool for making HTTP requests. connections : List [ httpcore . ConnectionInterface ] property readonly Return a list of the connections currently in the pool. For example: >>> pool . connections [ < HTTPConnection [ 'https://example.com:443' , HTTP / 1.1 , ACTIVE , Request Count : 6 ] > , < HTTPConnection [ 'https://example.com:443' , HTTP / 1.1 , IDLE , Request Count : 9 ] > , < HTTPConnection [ 'http://example.com:80' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , ] __init__ ( self , ssl_context = None , max_connections = 10 , max_keepalive_connections = None , keepalive_expiry = None , http1 = True , http2 = False , retries = 0 , local_address = None , uds = None , network_backend = None ) special A connection pool for making HTTP requests. Parameters: Name Type Description Default ssl_context Optional[ssl.SSLContext] An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used. None max_connections Optional[int] The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. 10 max_keepalive_connections Optional[int] The maximum number of idle HTTP connections that will be maintained in the pool. None keepalive_expiry Optional[float] The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool. None http1 bool A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True. True http2 bool A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False. False retries int The maximum number of retries when trying to establish a connection. 0 local_address Optional[str] Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). None uds Optional[str] Path to a Unix Domain Socket to use instead of TCP sockets. None network_backend Optional[httpcore.backends.base.NetworkBackend] A backend instance to use for handling network I/O. None close ( self ) Close any connections in the pool. handle_request ( self , request ) Send an HTTP request, and return an HTTP response. This is the core implementation that is called into by .request() or .stream() . response_closed ( self , status ) This method acts as a callback once the request/response cycle is complete. It is called into from the ConnectionPoolByteStream.close() method.","title":"Connection Pools"},{"location":"connection-pools/#connection-pools","text":"While the top-level API provides convenience functions for working with httpcore , in practice you'll almost always want to take advantage of the connection pooling functionality that it provides. To do so, instantiate a pool instance, and use it to send requests: import httpcore http = httpcore . ConnectionPool () r = http . request ( \"GET\" , \"https://www.example.com/\" ) print ( r ) # <Response [200]> Connection pools support the same .request() and .stream() APIs as described in the Quickstart . We can observe the benefits of connection pooling with a simple script like so: import httpcore import time http = httpcore . ConnectionPool () for counter in range ( 5 ): started = time . time () response = http . request ( \"GET\" , \"https://www.example.com/\" ) complete = time . time () print ( response , \"in %.3f seconds\" % ( complete - started )) The output should demonstrate the initial request as being substantially slower than the subsequent requests: <Response [200]> in {0.529} seconds <Response [200]> in {0.096} seconds <Response [200]> in {0.097} seconds <Response [200]> in {0.095} seconds <Response [200]> in {0.098} seconds This is to be expected. Once we've established a connection to \"www.example.com\" we're able to reuse it for following requests.","title":"Connection Pools"},{"location":"connection-pools/#configuration","text":"The connection pool instance is also the main point of configuration. Let's take a look at the various options that it provides:","title":"Configuration"},{"location":"connection-pools/#ssl-configuration","text":"ssl_context : An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used.","title":"SSL configuration"},{"location":"connection-pools/#pooling-configuration","text":"max_connections : The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. max_keepalive_connections : The maximum number of idle HTTP connections that will be maintained in the pool. keepalive_expiry : The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool.","title":"Pooling configuration"},{"location":"connection-pools/#http-version-support","text":"http1 : A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True . http2 : A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False .","title":"HTTP version support"},{"location":"connection-pools/#other-options","text":"retries : The maximum number of retries when trying to establish a connection. local_address : Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). uds : Path to a Unix Domain Socket to use instead of TCP sockets. network_backend : A backend instance to use for handling network I/O.","title":"Other options"},{"location":"connection-pools/#pool-lifespans","text":"Because connection pools hold onto network resources, careful developers may want to ensure that instances are properly closed once they are no longer required. Working with a single global instance isn't a bad idea for many use case, since the connection pool will automatically be closed when the __del__ method is called on it: # This is perfectly fine for most purposes. # The connection pool will automatically be closed when it is garbage collected, # or when the Python interpreter exits. http = httpcore . ConnectionPool () However, to be more explicit around the resource usage, we can use the connection pool within a context manager: with httpcore . ConnectionPool () as http : ... Or else close the pool explicitly: http = httpcore . ConnectionPool () try : ... finally : http . close ()","title":"Pool lifespans"},{"location":"connection-pools/#thread-and-task-safety","text":"Connection pools are designed to be thread-safe. Similarly, when using httpcore in an async context connection pools are task-safe. This means that you can have a single connection pool instance shared by multiple threads.","title":"Thread and task safety"},{"location":"connection-pools/#reference","text":"","title":"Reference"},{"location":"connection-pools/#httpcoreconnectionpool","text":"A connection pool for making HTTP requests.","title":"httpcore.ConnectionPool"},{"location":"connection-pools/#httpcore.ConnectionPool.connections","text":"Return a list of the connections currently in the pool. For example: >>> pool . connections [ < HTTPConnection [ 'https://example.com:443' , HTTP / 1.1 , ACTIVE , Request Count : 6 ] > , < HTTPConnection [ 'https://example.com:443' , HTTP / 1.1 , IDLE , Request Count : 9 ] > , < HTTPConnection [ 'http://example.com:80' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , ]","title":"connections"},{"location":"connection-pools/#httpcore.ConnectionPool.__init__","text":"A connection pool for making HTTP requests. Parameters: Name Type Description Default ssl_context Optional[ssl.SSLContext] An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used. None max_connections Optional[int] The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. 10 max_keepalive_connections Optional[int] The maximum number of idle HTTP connections that will be maintained in the pool. None keepalive_expiry Optional[float] The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool. None http1 bool A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True. True http2 bool A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False. False retries int The maximum number of retries when trying to establish a connection. 0 local_address Optional[str] Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). None uds Optional[str] Path to a Unix Domain Socket to use instead of TCP sockets. None network_backend Optional[httpcore.backends.base.NetworkBackend] A backend instance to use for handling network I/O. None","title":"__init__()"},{"location":"connection-pools/#httpcore.ConnectionPool.close","text":"Close any connections in the pool.","title":"close()"},{"location":"connection-pools/#httpcore.ConnectionPool.handle_request","text":"Send an HTTP request, and return an HTTP response. This is the core implementation that is called into by .request() or .stream() .","title":"handle_request()"},{"location":"connection-pools/#httpcore.ConnectionPool.response_closed","text":"This method acts as a callback once the request/response cycle is complete. It is called into from the ConnectionPoolByteStream.close() method.","title":"response_closed()"},{"location":"connections/","text":"Connections TODO Reference httpcore.HTTPConnection has_expired ( self ) Return True if the connection is in a state where it should be closed. This either means that the connection is idle and it has passed the expiry time on its keep-alive, or that server has sent an EOF. is_available ( self ) Return True if the connection is currently able to accept an outgoing request. An HTTP/1.1 connection will only be available if it is currently idle. An HTTP/2 connection will be available so long as the stream ID space is not yet exhausted, and the connection is not in an error state. While the connection is being established we may not yet know if it is going to result in an HTTP/1.1 or HTTP/2 connection. The connection should be treated as being available, but might ultimately raise NewConnectionRequired required exceptions if multiple requests are attempted over a connection that ends up being established as HTTP/1.1. is_closed ( self ) Return True if the connection has been closed. Used when a response is closed to determine if the connection may be returned to the connection pool or not. is_idle ( self ) Return True if the connection is currently idle. httpcore.HTTP11Connection has_expired ( self ) Return True if the connection is in a state where it should be closed. This either means that the connection is idle and it has passed the expiry time on its keep-alive, or that server has sent an EOF. is_available ( self ) Return True if the connection is currently able to accept an outgoing request. An HTTP/1.1 connection will only be available if it is currently idle. An HTTP/2 connection will be available so long as the stream ID space is not yet exhausted, and the connection is not in an error state. While the connection is being established we may not yet know if it is going to result in an HTTP/1.1 or HTTP/2 connection. The connection should be treated as being available, but might ultimately raise NewConnectionRequired required exceptions if multiple requests are attempted over a connection that ends up being established as HTTP/1.1. is_closed ( self ) Return True if the connection has been closed. Used when a response is closed to determine if the connection may be returned to the connection pool or not. is_idle ( self ) Return True if the connection is currently idle. httpcore.HTTP2Connection has_expired ( self ) Return True if the connection is in a state where it should be closed. This either means that the connection is idle and it has passed the expiry time on its keep-alive, or that server has sent an EOF. is_available ( self ) Return True if the connection is currently able to accept an outgoing request. An HTTP/1.1 connection will only be available if it is currently idle. An HTTP/2 connection will be available so long as the stream ID space is not yet exhausted, and the connection is not in an error state. While the connection is being established we may not yet know if it is going to result in an HTTP/1.1 or HTTP/2 connection. The connection should be treated as being available, but might ultimately raise NewConnectionRequired required exceptions if multiple requests are attempted over a connection that ends up being established as HTTP/1.1. is_closed ( self ) Return True if the connection has been closed. Used when a response is closed to determine if the connection may be returned to the connection pool or not. is_idle ( self ) Return True if the connection is currently idle.","title":"Connections"},{"location":"connections/#connections","text":"TODO","title":"Connections"},{"location":"connections/#reference","text":"","title":"Reference"},{"location":"connections/#httpcorehttpconnection","text":"","title":"httpcore.HTTPConnection"},{"location":"connections/#httpcore.HTTPConnection.has_expired","text":"Return True if the connection is in a state where it should be closed. This either means that the connection is idle and it has passed the expiry time on its keep-alive, or that server has sent an EOF.","title":"has_expired()"},{"location":"connections/#httpcore.HTTPConnection.is_available","text":"Return True if the connection is currently able to accept an outgoing request. An HTTP/1.1 connection will only be available if it is currently idle. An HTTP/2 connection will be available so long as the stream ID space is not yet exhausted, and the connection is not in an error state. While the connection is being established we may not yet know if it is going to result in an HTTP/1.1 or HTTP/2 connection. The connection should be treated as being available, but might ultimately raise NewConnectionRequired required exceptions if multiple requests are attempted over a connection that ends up being established as HTTP/1.1.","title":"is_available()"},{"location":"connections/#httpcore.HTTPConnection.is_closed","text":"Return True if the connection has been closed. Used when a response is closed to determine if the connection may be returned to the connection pool or not.","title":"is_closed()"},{"location":"connections/#httpcore.HTTPConnection.is_idle","text":"Return True if the connection is currently idle.","title":"is_idle()"},{"location":"connections/#httpcorehttp11connection","text":"","title":"httpcore.HTTP11Connection"},{"location":"connections/#httpcore.HTTP11Connection.has_expired","text":"Return True if the connection is in a state where it should be closed. This either means that the connection is idle and it has passed the expiry time on its keep-alive, or that server has sent an EOF.","title":"has_expired()"},{"location":"connections/#httpcore.HTTP11Connection.is_available","text":"Return True if the connection is currently able to accept an outgoing request. An HTTP/1.1 connection will only be available if it is currently idle. An HTTP/2 connection will be available so long as the stream ID space is not yet exhausted, and the connection is not in an error state. While the connection is being established we may not yet know if it is going to result in an HTTP/1.1 or HTTP/2 connection. The connection should be treated as being available, but might ultimately raise NewConnectionRequired required exceptions if multiple requests are attempted over a connection that ends up being established as HTTP/1.1.","title":"is_available()"},{"location":"connections/#httpcore.HTTP11Connection.is_closed","text":"Return True if the connection has been closed. Used when a response is closed to determine if the connection may be returned to the connection pool or not.","title":"is_closed()"},{"location":"connections/#httpcore.HTTP11Connection.is_idle","text":"Return True if the connection is currently idle.","title":"is_idle()"},{"location":"connections/#httpcorehttp2connection","text":"","title":"httpcore.HTTP2Connection"},{"location":"connections/#httpcore.HTTP2Connection.has_expired","text":"Return True if the connection is in a state where it should be closed. This either means that the connection is idle and it has passed the expiry time on its keep-alive, or that server has sent an EOF.","title":"has_expired()"},{"location":"connections/#httpcore.HTTP2Connection.is_available","text":"Return True if the connection is currently able to accept an outgoing request. An HTTP/1.1 connection will only be available if it is currently idle. An HTTP/2 connection will be available so long as the stream ID space is not yet exhausted, and the connection is not in an error state. While the connection is being established we may not yet know if it is going to result in an HTTP/1.1 or HTTP/2 connection. The connection should be treated as being available, but might ultimately raise NewConnectionRequired required exceptions if multiple requests are attempted over a connection that ends up being established as HTTP/1.1.","title":"is_available()"},{"location":"connections/#httpcore.HTTP2Connection.is_closed","text":"Return True if the connection has been closed. Used when a response is closed to determine if the connection may be returned to the connection pool or not.","title":"is_closed()"},{"location":"connections/#httpcore.HTTP2Connection.is_idle","text":"Return True if the connection is currently idle.","title":"is_idle()"},{"location":"exceptions/","text":"Exceptions The following exceptions may be raised when sending a request: httpcore.TimeoutException httpcore.PoolTimeout httpcore.ConnectTimeout httpcore.ReadTimeout httpcore.WriteTimeout httpcore.NetworkError httpcore.ConnectError httpcore.ReadError httpcore.WriteError httpcore.ProtocolError httpcore.RemoteProtocolError httpcore.LocalProtocolError httpcore.ProxyError httpcore.UnsupportedProtocol","title":"Exceptions"},{"location":"exceptions/#exceptions","text":"The following exceptions may be raised when sending a request: httpcore.TimeoutException httpcore.PoolTimeout httpcore.ConnectTimeout httpcore.ReadTimeout httpcore.WriteTimeout httpcore.NetworkError httpcore.ConnectError httpcore.ReadError httpcore.WriteError httpcore.ProtocolError httpcore.RemoteProtocolError httpcore.LocalProtocolError httpcore.ProxyError httpcore.UnsupportedProtocol","title":"Exceptions"},{"location":"extensions/","text":"Extensions The request/response API used by httpcore is kept deliberately simple and explicit. The Request and Response models are pretty slim wrappers around this core API: # Pseudo - code expressing the essentials of the request / response model . ( status_code : int , headers : List [ Tuple(bytes, bytes) ] , stream : Iterable [ bytes ] ) = handle_request ( method : bytes , url : URL , headers : List [ Tuple(bytes, bytes) ] , stream : Iterable [ bytes ] ) This is everything that's needed in order to represent an HTTP exchange. Well... almost. There is a maxim in Computer Science that \"All non-trivial abstractions, to some degree, are leaky\" . When an expression is leaky, it's important that it ought to at least leak only in well-defined places. In order to handle cases that don't otherwise fit inside this core abstraction, httpcore requests and responses have 'extensions'. These are a dictionary of optional additional information. Let's expand on our request/response abstraction... # Pseudo - code expressing the essentials of the request / response model , # plus extensions allowing for additional API that does not fit into # this abstraction . ( status_code : int , headers : List [ Tuple(bytes, bytes) ] , stream : Iterable [ bytes ] , extensions : dict ) = handle_request ( method : bytes , url : URL , headers : List [ Tuple(bytes, bytes) ] , stream : Iterable [ bytes ] , extensions : dict ) Several extensions are supported both on the request: r = httpcore . request ( \"GET\" , \"https://www.example.com\" , extensions = { \"timeout\" : { \"connect\" : 5.0 }} ) And on the response: r = httpcore . request ( \"GET\" , \"https://www.example.com\" ) print ( r . extensions [ \"http_version\" ]) # When using HTTP/1.1 on the client side, the server HTTP response # could feasibly be one of b\"HTTP/0.9\", b\"HTTP/1.0\", or b\"HTTP/1.1\". Request Extensions \"timeout\" A dictionary of str: Optional[float] timeout values. May include values for 'connect' , 'read' , 'write' , or 'pool' . For example: # Timeout if a connection takes more than 5 seconds to established, or if # we are blocked waiting on the connection pool for more than 10 seconds. r = httpcore . request ( \"GET\" , \"https://www.example.com\" , extensions = { \"timeout\" : { \"connect\" : 5.0 , \"pool\" : 10.0 }} ) \"trace\" The trace extension allows a callback handler to be installed to monitor the internal flow of events within httpcore . The simplest way to explain this is with an example: import httpcore def log ( event_name , info ): print ( event_name , info ) r = httpcore . request ( \"GET\" , \"https://www.example.com/\" , extensions = { \"trace\" : log }) # connection.connect_tcp.started {'host': 'www.example.com', 'port': 443, 'local_address': None, 'timeout': None} # connection.connect_tcp.complete {'return_value': <httpcore.backends.sync.SyncStream object at 0x1093f94d0>} # connection.start_tls.started {'ssl_context': <ssl.SSLContext object at 0x1093ee750>, 'server_hostname': b'www.example.com', 'timeout': None} # connection.start_tls.complete {'return_value': <httpcore.backends.sync.SyncStream object at 0x1093f9450>} # http11.send_request_headers.started {'request': <Request [b'GET']>} # http11.send_request_headers.complete {'return_value': None} # http11.send_request_body.started {'request': <Request [b'GET']>} # http11.send_request_body.complete {'return_value': None} # http11.receive_response_headers.started {'request': <Request [b'GET']>} # http11.receive_response_headers.complete {'return_value': (b'HTTP/1.1', 200, b'OK', [(b'Age', b'553715'), (b'Cache-Control', b'max-age=604800'), (b'Content-Type', b'text/html; charset=UTF-8'), (b'Date', b'Thu, 21 Oct 2021 17:08:42 GMT'), (b'Etag', b'\"3147526947+ident\"'), (b'Expires', b'Thu, 28 Oct 2021 17:08:42 GMT'), (b'Last-Modified', b'Thu, 17 Oct 2019 07:18:26 GMT'), (b'Server', b'ECS (nyb/1DCD)'), (b'Vary', b'Accept-Encoding'), (b'X-Cache', b'HIT'), (b'Content-Length', b'1256')])} # http11.receive_response_body.started {'request': <Request [b'GET']>} # http11.receive_response_body.complete {'return_value': None} # http11.response_closed.started {} # http11.response_closed.complete {'return_value': None} The event_name and info arguments here will be one of the following: {event_type}.{event_name}.started , <dictionary of keyword arguments> {event_type}.{event_name}.complete , {\"return_value\": <...>} {event_type}.{event_name}.failed , {\"exception\": <...>} Note that when using the async variant of httpcore the handler function passed to \"trace\" must be an async def ... function. The following event types are currently exposed... Establishing the connection \"connection.connect_tcp\" \"connection.connect_unix_socket\" \"connection.start_tls\" HTTP/1.1 events \"http11.send_request_headers\" \"http11.send_request_body\" \"http11.receive_response\" \"http11.receive_response_body\" \"http11.response_closed\" HTTP/2 events \"http2.send_connection_init\" \"http2.send_request_headers\" \"http2.send_request_body\" \"http2.receive_response_headers\" \"http2.receive_response_body\" \"http2.response_closed\" Response Extensions \"http_version\" The HTTP version, as bytes. Eg. b\"HTTP/1.1\" . When using HTTP/1.1 the response line includes an explicit version, and the value of this key could feasibly be one of b\"HTTP/0.9\" , b\"HTTP/1.0\" , or b\"HTTP/1.1\" . When using HTTP/2 there is no further response versioning included in the protocol, and the value of this key will always be b\"HTTP/2\" . \"reason_phrase\" The reason-phrase of the HTTP response, as bytes. For example b\"OK\" . Some servers may include a custom reason phrase, although this is not recommended. HTTP/2 onwards does not include a reason phrase on the wire. When no key is included, a default based on the status code may be used. \"network_stream\" The \"network_stream\" extension allows developers to handle HTTP CONNECT and Upgrade requests, by providing an API that steps outside the standard request/response model, and can directly read or write to the network. The interface provided by the network stream: read(max_bytes, timeout = None) -> bytes write(buffer, timeout = None) close() start_tls(ssl_context, server_hostname = None, timeout = None) -> NetworkStream get_extra_info(info) -> Any This API can be used as the foundation for working with HTTP proxies, WebSocket upgrades, and other advanced use-cases. An example to demonstrate: # Formulate a CONNECT request... # # This will establish a connection to 127.0.0.1:8080, and then send the following... # # CONNECT http://www.example.com HTTP/1.1 # Host: 127.0.0.1:8080 url = httpcore . URL ( b \"http\" , b \"127.0.0.1\" , 8080 , b \"http://www.example.com\" ) with httpcore . stream ( \"CONNECT\" , url ) as response : network_stream = response . extensions [ \"network_stream\" ] # Upgrade to an SSL stream... network_stream = network_stream . start_tls ( ssl_context = httpcore . default_ssl_context (), hostname = b \"www.example.com\" , ) # Manually send an HTTP request over the network stream, and read the response... # # For a more complete example see the httpcore `TunnelHTTPConnection` implementation. network_stream . write ( b \"GET / HTTP/1.1 \\r\\n Host: example.com \\r\\n\\r\\n \" ) data = network_stream . read () print ( data ) The network stream abstraction also allows access to various low-level information that may be exposed by the underlying socket: response = httpcore . request ( \"GET\" , \"https://www.example.com\" ) network_stream = response . extensions [ \"network_stream\" ] client_addr = network_stream . get_extra_info ( \"client_addr\" ) server_addr = network_stream . get_extra_info ( \"server_addr\" ) print ( \"Client address\" , client_addr ) print ( \"Server address\" , server_addr ) The socket SSL information is also available through this interface, although you need to ensure that the underlying connection is still open, in order to access it... with httpcore . stream ( \"GET\" , \"https://www.example.com\" ) as response : network_stream = response . extensions [ \"network_stream\" ] ssl_object = network_stream . get_extra_info ( \"ssl_object\" ) print ( \"TLS version\" , ssl_object . version ())","title":"Extensions"},{"location":"extensions/#extensions","text":"The request/response API used by httpcore is kept deliberately simple and explicit. The Request and Response models are pretty slim wrappers around this core API: # Pseudo - code expressing the essentials of the request / response model . ( status_code : int , headers : List [ Tuple(bytes, bytes) ] , stream : Iterable [ bytes ] ) = handle_request ( method : bytes , url : URL , headers : List [ Tuple(bytes, bytes) ] , stream : Iterable [ bytes ] ) This is everything that's needed in order to represent an HTTP exchange. Well... almost. There is a maxim in Computer Science that \"All non-trivial abstractions, to some degree, are leaky\" . When an expression is leaky, it's important that it ought to at least leak only in well-defined places. In order to handle cases that don't otherwise fit inside this core abstraction, httpcore requests and responses have 'extensions'. These are a dictionary of optional additional information. Let's expand on our request/response abstraction... # Pseudo - code expressing the essentials of the request / response model , # plus extensions allowing for additional API that does not fit into # this abstraction . ( status_code : int , headers : List [ Tuple(bytes, bytes) ] , stream : Iterable [ bytes ] , extensions : dict ) = handle_request ( method : bytes , url : URL , headers : List [ Tuple(bytes, bytes) ] , stream : Iterable [ bytes ] , extensions : dict ) Several extensions are supported both on the request: r = httpcore . request ( \"GET\" , \"https://www.example.com\" , extensions = { \"timeout\" : { \"connect\" : 5.0 }} ) And on the response: r = httpcore . request ( \"GET\" , \"https://www.example.com\" ) print ( r . extensions [ \"http_version\" ]) # When using HTTP/1.1 on the client side, the server HTTP response # could feasibly be one of b\"HTTP/0.9\", b\"HTTP/1.0\", or b\"HTTP/1.1\".","title":"Extensions"},{"location":"extensions/#request-extensions","text":"","title":"Request Extensions"},{"location":"extensions/#timeout","text":"A dictionary of str: Optional[float] timeout values. May include values for 'connect' , 'read' , 'write' , or 'pool' . For example: # Timeout if a connection takes more than 5 seconds to established, or if # we are blocked waiting on the connection pool for more than 10 seconds. r = httpcore . request ( \"GET\" , \"https://www.example.com\" , extensions = { \"timeout\" : { \"connect\" : 5.0 , \"pool\" : 10.0 }} )","title":"\"timeout\""},{"location":"extensions/#trace","text":"The trace extension allows a callback handler to be installed to monitor the internal flow of events within httpcore . The simplest way to explain this is with an example: import httpcore def log ( event_name , info ): print ( event_name , info ) r = httpcore . request ( \"GET\" , \"https://www.example.com/\" , extensions = { \"trace\" : log }) # connection.connect_tcp.started {'host': 'www.example.com', 'port': 443, 'local_address': None, 'timeout': None} # connection.connect_tcp.complete {'return_value': <httpcore.backends.sync.SyncStream object at 0x1093f94d0>} # connection.start_tls.started {'ssl_context': <ssl.SSLContext object at 0x1093ee750>, 'server_hostname': b'www.example.com', 'timeout': None} # connection.start_tls.complete {'return_value': <httpcore.backends.sync.SyncStream object at 0x1093f9450>} # http11.send_request_headers.started {'request': <Request [b'GET']>} # http11.send_request_headers.complete {'return_value': None} # http11.send_request_body.started {'request': <Request [b'GET']>} # http11.send_request_body.complete {'return_value': None} # http11.receive_response_headers.started {'request': <Request [b'GET']>} # http11.receive_response_headers.complete {'return_value': (b'HTTP/1.1', 200, b'OK', [(b'Age', b'553715'), (b'Cache-Control', b'max-age=604800'), (b'Content-Type', b'text/html; charset=UTF-8'), (b'Date', b'Thu, 21 Oct 2021 17:08:42 GMT'), (b'Etag', b'\"3147526947+ident\"'), (b'Expires', b'Thu, 28 Oct 2021 17:08:42 GMT'), (b'Last-Modified', b'Thu, 17 Oct 2019 07:18:26 GMT'), (b'Server', b'ECS (nyb/1DCD)'), (b'Vary', b'Accept-Encoding'), (b'X-Cache', b'HIT'), (b'Content-Length', b'1256')])} # http11.receive_response_body.started {'request': <Request [b'GET']>} # http11.receive_response_body.complete {'return_value': None} # http11.response_closed.started {} # http11.response_closed.complete {'return_value': None} The event_name and info arguments here will be one of the following: {event_type}.{event_name}.started , <dictionary of keyword arguments> {event_type}.{event_name}.complete , {\"return_value\": <...>} {event_type}.{event_name}.failed , {\"exception\": <...>} Note that when using the async variant of httpcore the handler function passed to \"trace\" must be an async def ... function. The following event types are currently exposed... Establishing the connection \"connection.connect_tcp\" \"connection.connect_unix_socket\" \"connection.start_tls\" HTTP/1.1 events \"http11.send_request_headers\" \"http11.send_request_body\" \"http11.receive_response\" \"http11.receive_response_body\" \"http11.response_closed\" HTTP/2 events \"http2.send_connection_init\" \"http2.send_request_headers\" \"http2.send_request_body\" \"http2.receive_response_headers\" \"http2.receive_response_body\" \"http2.response_closed\"","title":"\"trace\""},{"location":"extensions/#response-extensions","text":"","title":"Response Extensions"},{"location":"extensions/#http_version","text":"The HTTP version, as bytes. Eg. b\"HTTP/1.1\" . When using HTTP/1.1 the response line includes an explicit version, and the value of this key could feasibly be one of b\"HTTP/0.9\" , b\"HTTP/1.0\" , or b\"HTTP/1.1\" . When using HTTP/2 there is no further response versioning included in the protocol, and the value of this key will always be b\"HTTP/2\" .","title":"\"http_version\""},{"location":"extensions/#reason_phrase","text":"The reason-phrase of the HTTP response, as bytes. For example b\"OK\" . Some servers may include a custom reason phrase, although this is not recommended. HTTP/2 onwards does not include a reason phrase on the wire. When no key is included, a default based on the status code may be used.","title":"\"reason_phrase\""},{"location":"extensions/#network_stream","text":"The \"network_stream\" extension allows developers to handle HTTP CONNECT and Upgrade requests, by providing an API that steps outside the standard request/response model, and can directly read or write to the network. The interface provided by the network stream: read(max_bytes, timeout = None) -> bytes write(buffer, timeout = None) close() start_tls(ssl_context, server_hostname = None, timeout = None) -> NetworkStream get_extra_info(info) -> Any This API can be used as the foundation for working with HTTP proxies, WebSocket upgrades, and other advanced use-cases. An example to demonstrate: # Formulate a CONNECT request... # # This will establish a connection to 127.0.0.1:8080, and then send the following... # # CONNECT http://www.example.com HTTP/1.1 # Host: 127.0.0.1:8080 url = httpcore . URL ( b \"http\" , b \"127.0.0.1\" , 8080 , b \"http://www.example.com\" ) with httpcore . stream ( \"CONNECT\" , url ) as response : network_stream = response . extensions [ \"network_stream\" ] # Upgrade to an SSL stream... network_stream = network_stream . start_tls ( ssl_context = httpcore . default_ssl_context (), hostname = b \"www.example.com\" , ) # Manually send an HTTP request over the network stream, and read the response... # # For a more complete example see the httpcore `TunnelHTTPConnection` implementation. network_stream . write ( b \"GET / HTTP/1.1 \\r\\n Host: example.com \\r\\n\\r\\n \" ) data = network_stream . read () print ( data ) The network stream abstraction also allows access to various low-level information that may be exposed by the underlying socket: response = httpcore . request ( \"GET\" , \"https://www.example.com\" ) network_stream = response . extensions [ \"network_stream\" ] client_addr = network_stream . get_extra_info ( \"client_addr\" ) server_addr = network_stream . get_extra_info ( \"server_addr\" ) print ( \"Client address\" , client_addr ) print ( \"Server address\" , server_addr ) The socket SSL information is also available through this interface, although you need to ensure that the underlying connection is still open, in order to access it... with httpcore . stream ( \"GET\" , \"https://www.example.com\" ) as response : network_stream = response . extensions [ \"network_stream\" ] ssl_object = network_stream . get_extra_info ( \"ssl_object\" ) print ( \"TLS version\" , ssl_object . version ())","title":"\"network_stream\""},{"location":"http2/","text":"HTTP/2 HTTP/2 is a major new iteration of the HTTP protocol, that provides a more efficient transport, with potential performance benefits. HTTP/2 does not change the core semantics of the request or response, but alters the way that data is sent to and from the server. Rather than the text format that HTTP/1.1 uses, HTTP/2 is a binary format. The binary format provides full request and response multiplexing, and efficient compression of HTTP headers. The stream multiplexing means that where HTTP/1.1 requires one TCP stream for each concurrent request, HTTP/2 allows a single TCP stream to handle multiple concurrent requests. HTTP/2 also provides support for functionality such as response prioritization, and server push. For a comprehensive guide to HTTP/2 you may want to check out \" HTTP2 Explained \". Enabling HTTP/2 When using the httpcore client, HTTP/2 support is not enabled by default, because HTTP/1.1 is a mature, battle-hardened transport layer, and our HTTP/1.1 implementation may be considered the more robust option at this point in time. It is possible that a future version of httpcore may enable HTTP/2 support by default. If you're issuing highly concurrent requests you might want to consider trying out our HTTP/2 support. You can do so by first making sure to install the optional HTTP/2 dependencies... $ pip install httpcore [ http2 ] And then instantiating a connection pool with HTTP/2 support enabled: import httpcore pool = httpcore . ConnectionPool ( http2 = True ) We can take a look at the difference in behaviour by issuing several outgoing requests in parallel. Start out by using a standard HTTP/1.1 connection pool: import httpcore import concurrent.futures import time def download ( http , year ): http . request ( \"GET\" , f \"https://en.wikipedia.org/wiki/ { year } \" ) def main (): with httpcore . ConnectionPool () as http : started = time . time () with concurrent . futures . ThreadPoolExecutor ( max_workers = 10 ) as threads : for year in range ( 2000 , 2020 ): threads . submit ( download , http , year ) complete = time . time () for connection in http . connections : print ( connection ) print ( \"Complete in %.3f seconds\" % ( complete - started )) main () If you run this with an HTTP/1.1 connection pool, you ought to see output similar to the following: < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 2 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 3 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 6 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 5 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 1 ] > Complete in 0.586 seconds We can see that the connection pool required a number of connections in order to handle the parallel requests. If we now upgrade our connection pool to support HTTP/2: with httpcore . ConnectionPool ( http2 = True ) as http : ... And run the same script again, we should end up with something like this: < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 2 , IDLE , Request Count : 20 ] > Complete in 0.573 seconds All of our requests have been handled over a single connection. Switching to HTTP/2 should not necessarily be considered an \"upgrade\". It is more complex, and requires more computational power, and so particularly in an interpreted language like Python it could be slower in some instances. Moreover, utilising multiple connections may end up connecting to multiple hosts, and could sometimes appear faster to the client, at the cost of requiring more server resources. Enabling HTTP/2 is most likely to be beneficial if you are sending requests in high concurrency, and may often be more well suited to an async context, rather than multi-threading. Inspecting the HTTP version Enabling HTTP/2 support on the client does not necessarily mean that your requests and responses will be transported over HTTP/2, since both the client and the server need to support HTTP/2. If you connect to a server that only supports HTTP/1.1 the client will use a standard HTTP/1.1 connection instead. You can determine which version of the HTTP protocol was used by examining the \"http_version\" response extension. import httpcore pool = httpcore . ConnectionPool ( http2 = True ) response = pool . request ( \"GET\" , \"https://www.example.com/\" ) # Should be one of b\"HTTP/2\", b\"HTTP/1.1\", b\"HTTP/1.0\", or b\"HTTP/0.9\". print ( response . extensions [ \"http_version\" ]) See the extensions documentation for more details. HTTP/2 negotiation Robust servers need to support both HTTP/2 and HTTP/1.1 capable clients, and so need some way to \"negotiate\" with the client which protocol version will be used. HTTP/2 over HTTPS Generally the method used is for the server to advertise if it has HTTP/2 support during the part of the SSL connection handshake. This is known as ALPN - \"Application Layer Protocol Negotiation\". Most browsers only provide HTTP/2 support over HTTPS connections, and this is also the default behaviour that httpcore provides. If you enable HTTP/2 support you should still expect to see HTTP/1.1 connections for any http:// URLs. HTTP/2 over HTTP Servers can optionally also support HTTP/2 over HTTP by supporting the Upgrade: h2c header. This mechanism is not supported by httpcore . It requires an additional round-trip between the client and server, and also requires any request body to be sent twice. Prior Knowledge If you know in advance that the server you are communicating with will support HTTP/2, then you can enforce that the client uses HTTP/2, without requiring either ALPN support or an HTTP Upgrade: h2c header. This is managed by disabling HTTP/1.1 support on the connection pool: pool = httpcore . ConnectionPool ( http1 = False , http2 = True ) Request & response headers Because HTTP/2 frames the requests and responses somewhat differently to HTTP/1.1, there is a difference in some of the headers that are used. In order for the httpcore library to support both HTTP/1.1 and HTTP/2 transparently, the HTTP/1.1 style is always used throughout the API. Any differences in header styles are only mapped onto HTTP/2 at the internal network layer. Request headers The following pseudo-headers are used by HTTP/2 in the request: :method - The request method. :path - Taken from the URL of the request. :authority - Equivalent to the Host header in HTTP/1.1. In httpcore this is represented using the request Host header, which is automatically populated from the request URL if no Host header is explicitly included. :scheme - Taken from the URL of the request. These pseudo-headers are included in httpcore as part of the request.method and request.url attributes, and through the request.headers[\"Host\"] header. They are not exposed directly by their psuedo-header names. The one other difference to be aware of is the Transfer-Encoding: chunked header. In HTTP/2 this header is never used, since streaming data is framed using a different mechanism. In httpcore the Transfer-Encoding: chunked header is always used to represent the presence of a streaming body on the request, and is automatically populated if required. However the header is only sent if the underlying connection ends up being HTTP/1.1, and is omitted if the underlying connection ends up being HTTP/2. Response headers The following pseudo-header is used by HTTP/2 in the response: :status - The response status code. In httpcore this is represented by the response.status attribute, rather than being exposed as a psuedo-header .","title":"HTTP/2"},{"location":"http2/#http2","text":"HTTP/2 is a major new iteration of the HTTP protocol, that provides a more efficient transport, with potential performance benefits. HTTP/2 does not change the core semantics of the request or response, but alters the way that data is sent to and from the server. Rather than the text format that HTTP/1.1 uses, HTTP/2 is a binary format. The binary format provides full request and response multiplexing, and efficient compression of HTTP headers. The stream multiplexing means that where HTTP/1.1 requires one TCP stream for each concurrent request, HTTP/2 allows a single TCP stream to handle multiple concurrent requests. HTTP/2 also provides support for functionality such as response prioritization, and server push. For a comprehensive guide to HTTP/2 you may want to check out \" HTTP2 Explained \".","title":"HTTP/2"},{"location":"http2/#enabling-http2","text":"When using the httpcore client, HTTP/2 support is not enabled by default, because HTTP/1.1 is a mature, battle-hardened transport layer, and our HTTP/1.1 implementation may be considered the more robust option at this point in time. It is possible that a future version of httpcore may enable HTTP/2 support by default. If you're issuing highly concurrent requests you might want to consider trying out our HTTP/2 support. You can do so by first making sure to install the optional HTTP/2 dependencies... $ pip install httpcore [ http2 ] And then instantiating a connection pool with HTTP/2 support enabled: import httpcore pool = httpcore . ConnectionPool ( http2 = True ) We can take a look at the difference in behaviour by issuing several outgoing requests in parallel. Start out by using a standard HTTP/1.1 connection pool: import httpcore import concurrent.futures import time def download ( http , year ): http . request ( \"GET\" , f \"https://en.wikipedia.org/wiki/ { year } \" ) def main (): with httpcore . ConnectionPool () as http : started = time . time () with concurrent . futures . ThreadPoolExecutor ( max_workers = 10 ) as threads : for year in range ( 2000 , 2020 ): threads . submit ( download , http , year ) complete = time . time () for connection in http . connections : print ( connection ) print ( \"Complete in %.3f seconds\" % ( complete - started )) main () If you run this with an HTTP/1.1 connection pool, you ought to see output similar to the following: < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 2 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 3 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 6 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 5 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 1 ] > , < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 1.1 , IDLE , Request Count : 1 ] > Complete in 0.586 seconds We can see that the connection pool required a number of connections in order to handle the parallel requests. If we now upgrade our connection pool to support HTTP/2: with httpcore . ConnectionPool ( http2 = True ) as http : ... And run the same script again, we should end up with something like this: < HTTPConnection [ 'https://en.wikipedia.org:443' , HTTP / 2 , IDLE , Request Count : 20 ] > Complete in 0.573 seconds All of our requests have been handled over a single connection. Switching to HTTP/2 should not necessarily be considered an \"upgrade\". It is more complex, and requires more computational power, and so particularly in an interpreted language like Python it could be slower in some instances. Moreover, utilising multiple connections may end up connecting to multiple hosts, and could sometimes appear faster to the client, at the cost of requiring more server resources. Enabling HTTP/2 is most likely to be beneficial if you are sending requests in high concurrency, and may often be more well suited to an async context, rather than multi-threading.","title":"Enabling HTTP/2"},{"location":"http2/#inspecting-the-http-version","text":"Enabling HTTP/2 support on the client does not necessarily mean that your requests and responses will be transported over HTTP/2, since both the client and the server need to support HTTP/2. If you connect to a server that only supports HTTP/1.1 the client will use a standard HTTP/1.1 connection instead. You can determine which version of the HTTP protocol was used by examining the \"http_version\" response extension. import httpcore pool = httpcore . ConnectionPool ( http2 = True ) response = pool . request ( \"GET\" , \"https://www.example.com/\" ) # Should be one of b\"HTTP/2\", b\"HTTP/1.1\", b\"HTTP/1.0\", or b\"HTTP/0.9\". print ( response . extensions [ \"http_version\" ]) See the extensions documentation for more details.","title":"Inspecting the HTTP version"},{"location":"http2/#http2-negotiation","text":"Robust servers need to support both HTTP/2 and HTTP/1.1 capable clients, and so need some way to \"negotiate\" with the client which protocol version will be used.","title":"HTTP/2 negotiation"},{"location":"http2/#http2-over-https","text":"Generally the method used is for the server to advertise if it has HTTP/2 support during the part of the SSL connection handshake. This is known as ALPN - \"Application Layer Protocol Negotiation\". Most browsers only provide HTTP/2 support over HTTPS connections, and this is also the default behaviour that httpcore provides. If you enable HTTP/2 support you should still expect to see HTTP/1.1 connections for any http:// URLs.","title":"HTTP/2 over HTTPS"},{"location":"http2/#http2-over-http","text":"Servers can optionally also support HTTP/2 over HTTP by supporting the Upgrade: h2c header. This mechanism is not supported by httpcore . It requires an additional round-trip between the client and server, and also requires any request body to be sent twice.","title":"HTTP/2 over HTTP"},{"location":"http2/#prior-knowledge","text":"If you know in advance that the server you are communicating with will support HTTP/2, then you can enforce that the client uses HTTP/2, without requiring either ALPN support or an HTTP Upgrade: h2c header. This is managed by disabling HTTP/1.1 support on the connection pool: pool = httpcore . ConnectionPool ( http1 = False , http2 = True )","title":"Prior Knowledge"},{"location":"http2/#request-response-headers","text":"Because HTTP/2 frames the requests and responses somewhat differently to HTTP/1.1, there is a difference in some of the headers that are used. In order for the httpcore library to support both HTTP/1.1 and HTTP/2 transparently, the HTTP/1.1 style is always used throughout the API. Any differences in header styles are only mapped onto HTTP/2 at the internal network layer.","title":"Request &amp; response headers"},{"location":"http2/#request-headers","text":"The following pseudo-headers are used by HTTP/2 in the request: :method - The request method. :path - Taken from the URL of the request. :authority - Equivalent to the Host header in HTTP/1.1. In httpcore this is represented using the request Host header, which is automatically populated from the request URL if no Host header is explicitly included. :scheme - Taken from the URL of the request. These pseudo-headers are included in httpcore as part of the request.method and request.url attributes, and through the request.headers[\"Host\"] header. They are not exposed directly by their psuedo-header names. The one other difference to be aware of is the Transfer-Encoding: chunked header. In HTTP/2 this header is never used, since streaming data is framed using a different mechanism. In httpcore the Transfer-Encoding: chunked header is always used to represent the presence of a streaming body on the request, and is automatically populated if required. However the header is only sent if the underlying connection ends up being HTTP/1.1, and is omitted if the underlying connection ends up being HTTP/2.","title":"Request headers"},{"location":"http2/#response-headers","text":"The following pseudo-header is used by HTTP/2 in the response: :status - The response status code. In httpcore this is represented by the response.status attribute, rather than being exposed as a psuedo-header .","title":"Response headers"},{"location":"network-backends/","text":"Network Backends TODO","title":"Network Backends"},{"location":"network-backends/#network-backends","text":"TODO","title":"Network Backends"},{"location":"proxies/","text":"Proxies The httpcore package provides support for HTTP proxies, using either \"HTTP Forwarding\" or \"HTTP Tunnelling\". Forwarding is a proxy mechanism for sending requests to http URLs via an intermediate proxy. Tunnelling is a proxy mechanism for sending requests to https URLs via an intermediate proxy. Sending requests via a proxy is very similar to sending requests using a standard connection pool: import httpcore proxy = httpcore . HTTPProxy ( proxy_url = \"http://127.0.0.1:8080/\" ) r = proxy . request ( \"GET\" , \"https://www.example.com/\" ) print ( r ) # <Response [200]> You can test the httpcore proxy support, using the Python proxy.py tool: $ pip install proxy.py $ proxy --hostname 127 .0.0.1 --port 8080 Requests will automatically use either forwarding or tunnelling, depending on if the scheme is http or https . Authentication Proxy authentication can be included in the initial configuration: import httpcore # A `Proxy-Authorization` header will be included on the initial proxy connection. proxy = httpcore . HTTPProxy ( proxy_url = \"http://127.0.0.1:8080/\" , proxy_auth = ( \"<username>\" , \"<password>\" ) ) Custom headers can also be included: import httpcore import base64 # Construct and include a `Proxy-Authorization` header. auth = base64 . b64encode ( b \"<username>:<password>\" ) proxy = httpcore . HTTPProxy ( proxy_url = \"http://127.0.0.1:8080/\" , proxy_headers = { \"Proxy-Authorization\" : b \"Basic \" + auth } ) Proxy SSL and HTTP Versions Proxy support currently only allows for HTTP/1.1 connections to the proxy, and does not currently support SSL proxy connections, which require HTTPS-in-HTTPS, SOCKS proxy support The httpcore package also supports proxies using the SOCKS5 protocol. Make sure to install the optional dependancy using pip install httpcore[socks] . The SOCKSProxy class should be using instead of a standard connection pool: import httpcore # Note that the SOCKS port is 1080. proxy = httpcore . SOCKSProxy ( proxy_url = \"socks5://127.0.0.1:1080/\" ) r = proxy . request ( \"GET\" , \"https://www.example.com/\" ) Authentication via SOCKS is also supported: import httpcore proxy = httpcore . SOCKSProxy ( proxy_url = \"socks5://127.0.0.1:8080/\" , proxy_auth = ( \"<username>\" , \"<password>\" ) ) r = proxy . request ( \"GET\" , \"https://www.example.com/\" ) Reference httpcore.HTTPProxy A connection pool that sends requests via an HTTP proxy. __init__ ( self , proxy_url , proxy_auth = None , proxy_headers = None , ssl_context = None , max_connections = 10 , max_keepalive_connections = None , keepalive_expiry = None , http1 = True , http2 = False , retries = 0 , local_address = None , uds = None , network_backend = None ) special A connection pool for making HTTP requests. Parameters: Name Type Description Default proxy_url Union[httpcore.URL, bytes, str] The URL to use when connecting to the proxy server. For example \"http://127.0.0.1:8080/\" . required proxy_auth Optional[Tuple[Union[bytes, str], Union[bytes, str]]] Any proxy authentication as a two-tuple of (username, password). May be either bytes or ascii-only str. None proxy_headers Union[Mapping[Union[bytes, str], Union[bytes, str]], Sequence[Tuple[Union[bytes, str], Union[bytes, str]]]] Any HTTP headers to use for the proxy requests. For example {\"Proxy-Authorization\": \"Basic <username>:<password>\"} . None ssl_context Optional[ssl.SSLContext] An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used. None max_connections Optional[int] The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. 10 max_keepalive_connections Optional[int] The maximum number of idle HTTP connections that will be maintained in the pool. None keepalive_expiry Optional[float] The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool. None http1 bool A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True. True http2 bool A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False. False retries int The maximum number of retries when trying to establish a connection. 0 local_address Optional[str] Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). None uds Optional[str] Path to a Unix Domain Socket to use instead of TCP sockets. None network_backend Optional[httpcore.backends.base.NetworkBackend] A backend instance to use for handling network I/O. None","title":"Proxies"},{"location":"proxies/#proxies","text":"The httpcore package provides support for HTTP proxies, using either \"HTTP Forwarding\" or \"HTTP Tunnelling\". Forwarding is a proxy mechanism for sending requests to http URLs via an intermediate proxy. Tunnelling is a proxy mechanism for sending requests to https URLs via an intermediate proxy. Sending requests via a proxy is very similar to sending requests using a standard connection pool: import httpcore proxy = httpcore . HTTPProxy ( proxy_url = \"http://127.0.0.1:8080/\" ) r = proxy . request ( \"GET\" , \"https://www.example.com/\" ) print ( r ) # <Response [200]> You can test the httpcore proxy support, using the Python proxy.py tool: $ pip install proxy.py $ proxy --hostname 127 .0.0.1 --port 8080 Requests will automatically use either forwarding or tunnelling, depending on if the scheme is http or https .","title":"Proxies"},{"location":"proxies/#authentication","text":"Proxy authentication can be included in the initial configuration: import httpcore # A `Proxy-Authorization` header will be included on the initial proxy connection. proxy = httpcore . HTTPProxy ( proxy_url = \"http://127.0.0.1:8080/\" , proxy_auth = ( \"<username>\" , \"<password>\" ) ) Custom headers can also be included: import httpcore import base64 # Construct and include a `Proxy-Authorization` header. auth = base64 . b64encode ( b \"<username>:<password>\" ) proxy = httpcore . HTTPProxy ( proxy_url = \"http://127.0.0.1:8080/\" , proxy_headers = { \"Proxy-Authorization\" : b \"Basic \" + auth } )","title":"Authentication"},{"location":"proxies/#proxy-ssl-and-http-versions","text":"Proxy support currently only allows for HTTP/1.1 connections to the proxy, and does not currently support SSL proxy connections, which require HTTPS-in-HTTPS,","title":"Proxy SSL and HTTP Versions"},{"location":"proxies/#socks-proxy-support","text":"The httpcore package also supports proxies using the SOCKS5 protocol. Make sure to install the optional dependancy using pip install httpcore[socks] . The SOCKSProxy class should be using instead of a standard connection pool: import httpcore # Note that the SOCKS port is 1080. proxy = httpcore . SOCKSProxy ( proxy_url = \"socks5://127.0.0.1:1080/\" ) r = proxy . request ( \"GET\" , \"https://www.example.com/\" ) Authentication via SOCKS is also supported: import httpcore proxy = httpcore . SOCKSProxy ( proxy_url = \"socks5://127.0.0.1:8080/\" , proxy_auth = ( \"<username>\" , \"<password>\" ) ) r = proxy . request ( \"GET\" , \"https://www.example.com/\" )","title":"SOCKS proxy support"},{"location":"proxies/#reference","text":"","title":"Reference"},{"location":"proxies/#httpcorehttpproxy","text":"A connection pool that sends requests via an HTTP proxy.","title":"httpcore.HTTPProxy"},{"location":"proxies/#httpcore.HTTPProxy.__init__","text":"A connection pool for making HTTP requests. Parameters: Name Type Description Default proxy_url Union[httpcore.URL, bytes, str] The URL to use when connecting to the proxy server. For example \"http://127.0.0.1:8080/\" . required proxy_auth Optional[Tuple[Union[bytes, str], Union[bytes, str]]] Any proxy authentication as a two-tuple of (username, password). May be either bytes or ascii-only str. None proxy_headers Union[Mapping[Union[bytes, str], Union[bytes, str]], Sequence[Tuple[Union[bytes, str], Union[bytes, str]]]] Any HTTP headers to use for the proxy requests. For example {\"Proxy-Authorization\": \"Basic <username>:<password>\"} . None ssl_context Optional[ssl.SSLContext] An SSL context to use for verifying connections. If not specified, the default httpcore.default_ssl_context() will be used. None max_connections Optional[int] The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available. 10 max_keepalive_connections Optional[int] The maximum number of idle HTTP connections that will be maintained in the pool. None keepalive_expiry Optional[float] The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool. None http1 bool A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True. True http2 bool A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False. False retries int The maximum number of retries when trying to establish a connection. 0 local_address Optional[str] Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). None uds Optional[str] Path to a Unix Domain Socket to use instead of TCP sockets. None network_backend Optional[httpcore.backends.base.NetworkBackend] A backend instance to use for handling network I/O. None","title":"__init__()"},{"location":"quickstart/","text":"Quickstart For convenience, the httpcore package provides a couple of top-level functions that you can use for sending HTTP requests. You probably don't want to integrate against functions if you're writing a library that uses httpcore , but you might find them useful for testing httpcore from the command-line, or if you're writing a simple script that doesn't require any of the connection pooling or advanced configuration that httpcore offers. Sending a request We'll start off by sending a request... import httpcore response = httpcore . request ( \"GET\" , \"https://www.example.com/\" ) print ( response ) # <Response [200]> print ( response . status ) # 200 print ( response . headers ) # [(b'Accept-Ranges', b'bytes'), (b'Age', b'557328'), (b'Cache-Control', b'max-age=604800'), ...] print ( response . content ) # b'<!doctype html>\\n<html>\\n<head>\\n<title>Example Domain</title>\\n\\n<meta charset=\"utf-8\"/>\\n ...' Request headers Request headers may be included either in a dictionary style, or as a list of two-tuples. import httpcore import json headers = { 'User-Agent' : 'httpcore' } r = httpcore . request ( 'GET' , 'https://httpbin.org/headers' , headers = headers ) print ( json . loads ( r . content )) # { # 'headers': { # 'Host': 'httpbin.org', # 'User-Agent': 'httpcore', # 'X-Amzn-Trace-Id': 'Root=1-616ff5de-5ea1b7e12766f1cf3b8e3a33' # } # } The keys and values may either be provided as strings or as bytes. Where strings are provided they may only contain characters within the ASCII range chr(0) - chr(127) . To include characters outside this range you must deal with any character encoding explicitly, and pass bytes as the header keys/values. The Host header will always be automatically included in any outgoing request, as it is strictly required to be present by the HTTP protocol. Note that the X-Amzn-Trace-Id header shown in the example above is not an outgoing request header, but has been added by a gateway server. Request body A request body can be included either as bytes... import httpcore import json r = httpcore . request ( 'POST' , 'https://httpbin.org/post' , content = b 'Hello, world' ) print ( json . loads ( r . content )) # { # 'args': {}, # 'data': 'Hello, world', # 'files': {}, # 'form': {}, # 'headers': { # 'Host': 'httpbin.org', # 'Content-Length': '12', # 'X-Amzn-Trace-Id': 'Root=1-61700258-00e338a124ca55854bf8435f' # }, # 'json': None, # 'origin': '68.41.35.196', # 'url': 'https://httpbin.org/post' # } Or as an iterable that returns bytes... import httpcore import json with open ( \"hello-world.txt\" , \"rb\" ) as input_file : r = httpcore . request ( 'POST' , 'https://httpbin.org/post' , content = input_file ) print ( json . loads ( r . content )) # { # 'args': {}, # 'data': 'Hello, world', # 'files': {}, # 'form': {}, # 'headers': { # 'Host': 'httpbin.org', # 'Transfer-Encoding': 'chunked', # 'X-Amzn-Trace-Id': 'Root=1-61700258-00e338a124ca55854bf8435f' # }, # 'json': None, # 'origin': '68.41.35.196', # 'url': 'https://httpbin.org/post' # } When a request body is included, either a Content-Length header or a Transfer-Encoding: chunked header will be automatically included. The Content-Length header is used when passing bytes, and indicates an HTTP request with a body of a pre-determined length. The Transfer-Encoding: chunked header is the mechanism that HTTP/1.1 uses for sending HTTP request bodies without a pre-determined length. Streaming responses When using the httpcore.request() function, the response body will automatically be read to completion, and made available in the response.content attribute. Sometimes you may be dealing with large responses and not want to read the entire response into memory. The httpcore.stream() function provides a mechanism for sending a request and dealing with a streaming response: import httpcore with httpcore . stream ( 'GET' , 'https://example.com' ) as response : for chunk in response . iter_stream (): print ( f \"Downloaded: { chunk } \" ) Here's a more complete example that demonstrates downloading a response: import httpcore with httpcore . stream ( 'GET' , 'https://speed.hetzner.de/100MB.bin' ) as response : with open ( \"download.bin\" , \"wb\" ) as output_file : for chunk in response . iter_stream (): output_file . write ( chunk ) The httpcore.stream() API also allows you to conditionally read the response... import httpcore with httpcore . stream ( 'GET' , 'https://example.com' ) as response : content_length = [ int ( v ) for k , v in response . headers if k . lower () == b 'content-length' ][ 0 ] if content_length > 100_000_000 : raise Exception ( \"Response too large.\" ) response . read () # `response.content` is now available. Reference httpcore.request() Sends an HTTP request, returning the response. response = httpcore.request(\"GET\", \"https://www.example.com/\") Parameters: Name Type Description Default method Union[bytes, str] The HTTP method for the request. Typically one of \"GET\" , \"OPTIONS\" , \"HEAD\" , \"POST\" , \"PUT\" , \"PATCH\" , or \"DELETE\" . required url Union[httpcore.URL, bytes, str] The URL of the HTTP request. Either as an instance of httpcore.URL , or as str/bytes. required headers Union[dict, list] The HTTP request headers. Either as a dictionary of str/bytes, or as a list of two-tuples of str/bytes. None content Union[bytes, Iterator[bytes]] The content of the request body. Either as bytes, or as a bytes iterator. None extensions Optional[dict] A dictionary of optional extra information included on the request. Possible keys include \"timeout\" . None Returns: Type Description Response An instance of httpcore.Response . httpcore.stream() Sends an HTTP request, returning the response within a content manager. with httpcore.stream(\"GET\", \"https://www.example.com/\") as response: ... When using the stream() function, the body of the response will not be automatically read. If you want to access the response body you should either use content = response.read() , or for chunk in response.iter_content() . Parameters: Name Type Description Default method Union[bytes, str] The HTTP method for the request. Typically one of \"GET\" , \"OPTIONS\" , \"HEAD\" , \"POST\" , \"PUT\" , \"PATCH\" , or \"DELETE\" . required url Union[httpcore.URL, bytes, str] The URL of the HTTP request. Either as an instance of httpcore.URL , or as str/bytes. required headers Union[dict, list] The HTTP request headers. Either as a dictionary of str/bytes, or as a list of two-tuples of str/bytes. None content Union[bytes, Iterator[bytes]] The content of the request body. Either as bytes, or as a bytes iterator. None extensions Optional[dict] A dictionary of optional extra information included on the request. Possible keys include \"timeout\" . None Returns: Type Description Iterator[httpcore.Response] An instance of httpcore.Response .","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"For convenience, the httpcore package provides a couple of top-level functions that you can use for sending HTTP requests. You probably don't want to integrate against functions if you're writing a library that uses httpcore , but you might find them useful for testing httpcore from the command-line, or if you're writing a simple script that doesn't require any of the connection pooling or advanced configuration that httpcore offers.","title":"Quickstart"},{"location":"quickstart/#sending-a-request","text":"We'll start off by sending a request... import httpcore response = httpcore . request ( \"GET\" , \"https://www.example.com/\" ) print ( response ) # <Response [200]> print ( response . status ) # 200 print ( response . headers ) # [(b'Accept-Ranges', b'bytes'), (b'Age', b'557328'), (b'Cache-Control', b'max-age=604800'), ...] print ( response . content ) # b'<!doctype html>\\n<html>\\n<head>\\n<title>Example Domain</title>\\n\\n<meta charset=\"utf-8\"/>\\n ...'","title":"Sending a request"},{"location":"quickstart/#request-headers","text":"Request headers may be included either in a dictionary style, or as a list of two-tuples. import httpcore import json headers = { 'User-Agent' : 'httpcore' } r = httpcore . request ( 'GET' , 'https://httpbin.org/headers' , headers = headers ) print ( json . loads ( r . content )) # { # 'headers': { # 'Host': 'httpbin.org', # 'User-Agent': 'httpcore', # 'X-Amzn-Trace-Id': 'Root=1-616ff5de-5ea1b7e12766f1cf3b8e3a33' # } # } The keys and values may either be provided as strings or as bytes. Where strings are provided they may only contain characters within the ASCII range chr(0) - chr(127) . To include characters outside this range you must deal with any character encoding explicitly, and pass bytes as the header keys/values. The Host header will always be automatically included in any outgoing request, as it is strictly required to be present by the HTTP protocol. Note that the X-Amzn-Trace-Id header shown in the example above is not an outgoing request header, but has been added by a gateway server.","title":"Request headers"},{"location":"quickstart/#request-body","text":"A request body can be included either as bytes... import httpcore import json r = httpcore . request ( 'POST' , 'https://httpbin.org/post' , content = b 'Hello, world' ) print ( json . loads ( r . content )) # { # 'args': {}, # 'data': 'Hello, world', # 'files': {}, # 'form': {}, # 'headers': { # 'Host': 'httpbin.org', # 'Content-Length': '12', # 'X-Amzn-Trace-Id': 'Root=1-61700258-00e338a124ca55854bf8435f' # }, # 'json': None, # 'origin': '68.41.35.196', # 'url': 'https://httpbin.org/post' # } Or as an iterable that returns bytes... import httpcore import json with open ( \"hello-world.txt\" , \"rb\" ) as input_file : r = httpcore . request ( 'POST' , 'https://httpbin.org/post' , content = input_file ) print ( json . loads ( r . content )) # { # 'args': {}, # 'data': 'Hello, world', # 'files': {}, # 'form': {}, # 'headers': { # 'Host': 'httpbin.org', # 'Transfer-Encoding': 'chunked', # 'X-Amzn-Trace-Id': 'Root=1-61700258-00e338a124ca55854bf8435f' # }, # 'json': None, # 'origin': '68.41.35.196', # 'url': 'https://httpbin.org/post' # } When a request body is included, either a Content-Length header or a Transfer-Encoding: chunked header will be automatically included. The Content-Length header is used when passing bytes, and indicates an HTTP request with a body of a pre-determined length. The Transfer-Encoding: chunked header is the mechanism that HTTP/1.1 uses for sending HTTP request bodies without a pre-determined length.","title":"Request body"},{"location":"quickstart/#streaming-responses","text":"When using the httpcore.request() function, the response body will automatically be read to completion, and made available in the response.content attribute. Sometimes you may be dealing with large responses and not want to read the entire response into memory. The httpcore.stream() function provides a mechanism for sending a request and dealing with a streaming response: import httpcore with httpcore . stream ( 'GET' , 'https://example.com' ) as response : for chunk in response . iter_stream (): print ( f \"Downloaded: { chunk } \" ) Here's a more complete example that demonstrates downloading a response: import httpcore with httpcore . stream ( 'GET' , 'https://speed.hetzner.de/100MB.bin' ) as response : with open ( \"download.bin\" , \"wb\" ) as output_file : for chunk in response . iter_stream (): output_file . write ( chunk ) The httpcore.stream() API also allows you to conditionally read the response... import httpcore with httpcore . stream ( 'GET' , 'https://example.com' ) as response : content_length = [ int ( v ) for k , v in response . headers if k . lower () == b 'content-length' ][ 0 ] if content_length > 100_000_000 : raise Exception ( \"Response too large.\" ) response . read () # `response.content` is now available.","title":"Streaming responses"},{"location":"quickstart/#reference","text":"","title":"Reference"},{"location":"quickstart/#httpcorerequest","text":"Sends an HTTP request, returning the response. response = httpcore.request(\"GET\", \"https://www.example.com/\") Parameters: Name Type Description Default method Union[bytes, str] The HTTP method for the request. Typically one of \"GET\" , \"OPTIONS\" , \"HEAD\" , \"POST\" , \"PUT\" , \"PATCH\" , or \"DELETE\" . required url Union[httpcore.URL, bytes, str] The URL of the HTTP request. Either as an instance of httpcore.URL , or as str/bytes. required headers Union[dict, list] The HTTP request headers. Either as a dictionary of str/bytes, or as a list of two-tuples of str/bytes. None content Union[bytes, Iterator[bytes]] The content of the request body. Either as bytes, or as a bytes iterator. None extensions Optional[dict] A dictionary of optional extra information included on the request. Possible keys include \"timeout\" . None Returns: Type Description Response An instance of httpcore.Response .","title":"httpcore.request()"},{"location":"quickstart/#httpcorestream","text":"Sends an HTTP request, returning the response within a content manager. with httpcore.stream(\"GET\", \"https://www.example.com/\") as response: ... When using the stream() function, the body of the response will not be automatically read. If you want to access the response body you should either use content = response.read() , or for chunk in response.iter_content() . Parameters: Name Type Description Default method Union[bytes, str] The HTTP method for the request. Typically one of \"GET\" , \"OPTIONS\" , \"HEAD\" , \"POST\" , \"PUT\" , \"PATCH\" , or \"DELETE\" . required url Union[httpcore.URL, bytes, str] The URL of the HTTP request. Either as an instance of httpcore.URL , or as str/bytes. required headers Union[dict, list] The HTTP request headers. Either as a dictionary of str/bytes, or as a list of two-tuples of str/bytes. None content Union[bytes, Iterator[bytes]] The content of the request body. Either as bytes, or as a bytes iterator. None extensions Optional[dict] A dictionary of optional extra information included on the request. Possible keys include \"timeout\" . None Returns: Type Description Iterator[httpcore.Response] An instance of httpcore.Response .","title":"httpcore.stream()"},{"location":"requests-responses-urls/","text":"Requests, Responses, and URLs TODO Requests Request instances in httpcore are deliberately simple, and only include the essential information required to represent an HTTP request. Properties on the request are plain byte-wise representations. >>> request = httpcore . Request ( \"GET\" , \"https://www.example.com/\" ) >>> request . method b \"GET\" >>> request . url httpcore . URL ( scheme = b \"https\" , host = b \"www.example.com\" , port = None , target = b \"/\" ) >>> request . headers [( b 'Host' , b 'www.example.com' )] >>> request . stream < httpcore . ByteStream [ 0 bytes ] > The interface is liberal in the types that it accepts, but specific in the properties that it uses to represent them. For example, headers may be specified as a dictionary of strings, but internally are represented as a list of (byte, byte) tuples. ```python headers = {\"User-Agent\": \"custom\"} request = httpcore.Request(\"GET\", \"https://www.example.com/\", headers=headers) request.headers [(b'Host', b'www.example.com'), (b\"User-Agent\", b\"custom\")] Responses ... URLs ... Reference httpcore.Request An HTTP request. __init__ ( self , method , url , * , headers = None , content = None , extensions = None ) special Parameters: Name Type Description Default method Union[bytes, str] The HTTP request method, either as a string or bytes. For example: GET . required url Union[httpcore.URL, bytes, str] The request URL, either as a URL instance, or as a string or bytes. For example: \"https://www.example.com\". required headers Union[dict, list] The HTTP request headers. None content Union[bytes, Iterable[bytes], AsyncIterable[bytes]] The content of the response body. None extensions Optional[dict] A dictionary of optional extra information included on the request. Possible keys include \"timeout\" , and \"trace\" . None httpcore.Response An HTTP response. __init__ ( self , status , * , headers = None , content = None , extensions = None ) special Parameters: Name Type Description Default status int The HTTP status code of the response. For example 200 . required headers Union[dict, list] The HTTP response headers. None content Union[bytes, Iterable[bytes], AsyncIterable[bytes]] The content of the response body. None extensions Optional[dict] A dictionary of optional extra information included on the responseself.Possible keys include \"http_version\" , \"reason_phrase\" , and \"network_stream\" . None httpcore.URL Represents the URL against which an HTTP request may be made. The URL may either be specified as a plain string, for convienence: url = httpcore . URL ( \"https://www.example.com/\" ) Or be constructed with explicitily pre-parsed components: url = httpcore . URL ( scheme = b 'https' , host = b 'www.example.com' , port = None , target = b '/' ) Using this second more explicit style allows integrations that are using httpcore to pass through URLs that have already been parsed in order to use libraries such as rfc-3986 rather than relying on the stdlib. It also ensures that URL parsing is treated identically at both the networking level and at any higher layers of abstraction. The four components are important here, as they allow the URL to be precisely specified in a pre-parsed format. They also allow certain types of request to be created that could not otherwise be expressed. For example, an HTTP request to http://www.example.com/ forwarded via a proxy at http://localhost:8080 ... # Constructs an HTTP request with a complete URL as the target: # GET https://www.example.com/ HTTP/1.1 url = httpcore . URL ( scheme = b 'http' , host = b 'localhost' , port = 8080 , target = b 'https://www.example.com/' ) request = httpcore . Request ( method = \"GET\" , url = url ) Another example is constructing an OPTIONS * request... # Constructs an 'OPTIONS *' HTTP request: # OPTIONS * HTTP/1.1 url = httpcore . URL ( scheme = b 'https' , host = b 'www.example.com' , target = b '*' ) request = httpcore . Request ( method = \"OPTIONS\" , url = url ) This kind of request is not possible to formulate with a URL string, because the / delimiter is always used to demark the target from the host/port portion of the URL. For convenience, string-like arguments may be specified either as strings or as bytes. However, once a request is being issue over-the-wire, the URL components are always ultimately required to be a bytewise representation. In order to avoid any ambiguity over character encodings, when strings are used as arguments, they must be strictly limited to the ASCII range chr(0) - chr(127) . If you require a bytewise representation that is outside this range you must handle the character encoding directly, and pass a bytes instance. __init__ ( self , url = '' , * , scheme = b '' , host = b '' , port = None , target = b '' ) special Parameters: Name Type Description Default url Union[bytes, str] The complete URL as a string or bytes. '' scheme Union[bytes, str] The URL scheme as a string or bytes. Typically either \"http\" or \"https\" . b'' host Union[bytes, str] The URL host as a string or bytes. Such as \"www.example.com\" . b'' port Optional[int] The port to connect to. Either an integer or None . None target Union[bytes, str] The target of the HTTP request. Such as \"/items?search=red\" . b''","title":"Requests, Responses, and URLs"},{"location":"requests-responses-urls/#requests-responses-and-urls","text":"TODO","title":"Requests, Responses, and URLs"},{"location":"requests-responses-urls/#requests","text":"Request instances in httpcore are deliberately simple, and only include the essential information required to represent an HTTP request. Properties on the request are plain byte-wise representations. >>> request = httpcore . Request ( \"GET\" , \"https://www.example.com/\" ) >>> request . method b \"GET\" >>> request . url httpcore . URL ( scheme = b \"https\" , host = b \"www.example.com\" , port = None , target = b \"/\" ) >>> request . headers [( b 'Host' , b 'www.example.com' )] >>> request . stream < httpcore . ByteStream [ 0 bytes ] > The interface is liberal in the types that it accepts, but specific in the properties that it uses to represent them. For example, headers may be specified as a dictionary of strings, but internally are represented as a list of (byte, byte) tuples. ```python headers = {\"User-Agent\": \"custom\"} request = httpcore.Request(\"GET\", \"https://www.example.com/\", headers=headers) request.headers [(b'Host', b'www.example.com'), (b\"User-Agent\", b\"custom\")]","title":"Requests"},{"location":"requests-responses-urls/#responses","text":"...","title":"Responses"},{"location":"requests-responses-urls/#urls","text":"...","title":"URLs"},{"location":"requests-responses-urls/#reference","text":"","title":"Reference"},{"location":"requests-responses-urls/#httpcorerequest","text":"An HTTP request.","title":"httpcore.Request"},{"location":"requests-responses-urls/#httpcore.Request.__init__","text":"Parameters: Name Type Description Default method Union[bytes, str] The HTTP request method, either as a string or bytes. For example: GET . required url Union[httpcore.URL, bytes, str] The request URL, either as a URL instance, or as a string or bytes. For example: \"https://www.example.com\". required headers Union[dict, list] The HTTP request headers. None content Union[bytes, Iterable[bytes], AsyncIterable[bytes]] The content of the response body. None extensions Optional[dict] A dictionary of optional extra information included on the request. Possible keys include \"timeout\" , and \"trace\" . None","title":"__init__()"},{"location":"requests-responses-urls/#httpcoreresponse","text":"An HTTP response.","title":"httpcore.Response"},{"location":"requests-responses-urls/#httpcore.Response.__init__","text":"Parameters: Name Type Description Default status int The HTTP status code of the response. For example 200 . required headers Union[dict, list] The HTTP response headers. None content Union[bytes, Iterable[bytes], AsyncIterable[bytes]] The content of the response body. None extensions Optional[dict] A dictionary of optional extra information included on the responseself.Possible keys include \"http_version\" , \"reason_phrase\" , and \"network_stream\" . None","title":"__init__()"},{"location":"requests-responses-urls/#httpcoreurl","text":"Represents the URL against which an HTTP request may be made. The URL may either be specified as a plain string, for convienence: url = httpcore . URL ( \"https://www.example.com/\" ) Or be constructed with explicitily pre-parsed components: url = httpcore . URL ( scheme = b 'https' , host = b 'www.example.com' , port = None , target = b '/' ) Using this second more explicit style allows integrations that are using httpcore to pass through URLs that have already been parsed in order to use libraries such as rfc-3986 rather than relying on the stdlib. It also ensures that URL parsing is treated identically at both the networking level and at any higher layers of abstraction. The four components are important here, as they allow the URL to be precisely specified in a pre-parsed format. They also allow certain types of request to be created that could not otherwise be expressed. For example, an HTTP request to http://www.example.com/ forwarded via a proxy at http://localhost:8080 ... # Constructs an HTTP request with a complete URL as the target: # GET https://www.example.com/ HTTP/1.1 url = httpcore . URL ( scheme = b 'http' , host = b 'localhost' , port = 8080 , target = b 'https://www.example.com/' ) request = httpcore . Request ( method = \"GET\" , url = url ) Another example is constructing an OPTIONS * request... # Constructs an 'OPTIONS *' HTTP request: # OPTIONS * HTTP/1.1 url = httpcore . URL ( scheme = b 'https' , host = b 'www.example.com' , target = b '*' ) request = httpcore . Request ( method = \"OPTIONS\" , url = url ) This kind of request is not possible to formulate with a URL string, because the / delimiter is always used to demark the target from the host/port portion of the URL. For convenience, string-like arguments may be specified either as strings or as bytes. However, once a request is being issue over-the-wire, the URL components are always ultimately required to be a bytewise representation. In order to avoid any ambiguity over character encodings, when strings are used as arguments, they must be strictly limited to the ASCII range chr(0) - chr(127) . If you require a bytewise representation that is outside this range you must handle the character encoding directly, and pass a bytes instance.","title":"httpcore.URL"},{"location":"requests-responses-urls/#httpcore.URL.__init__","text":"Parameters: Name Type Description Default url Union[bytes, str] The complete URL as a string or bytes. '' scheme Union[bytes, str] The URL scheme as a string or bytes. Typically either \"http\" or \"https\" . b'' host Union[bytes, str] The URL host as a string or bytes. Such as \"www.example.com\" . b'' port Optional[int] The port to connect to. Either an integer or None . None target Union[bytes, str] The target of the HTTP request. Such as \"/items?search=red\" . b''","title":"__init__()"},{"location":"table-of-contents/","text":"API Reference Quickstart httpcore.request() httpcore.stream() Requests, Responses, and URLs httpcore.Request httpcore.Response httpcore.URL Connection Pools httpcore.ConnectionPool Proxies httpcore.HTTPProxy Connections httpcore.HTTPConnection httpcore.HTTP11Connection httpcore.HTTP2Connection Async Support httpcore.AsyncConnectionPool httpcore.AsyncHTTPProxy httpcore.AsyncHTTPConnection httpcore.AsyncHTTP11Connection httpcore.AsyncHTTP2Connection Network Backends Sync httpcore.backends.sync.SyncBackend httpcore.backends.mock.MockBackend Async httpcore.backends.auto.AutoBackend httpcore.backends.asyncio.AsyncioBackend httpcore.backends.trio.TrioBackend httpcore.backends.mock.AsyncMockBackend Base interfaces httpcore.backends.base.NetworkBackend httpcore.backends.base.AsyncNetworkBackend Exceptions httpcore.TimeoutException httpcore.PoolTimeout httpcore.ConnectTimeout httpcore.ReadTimeout httpcore.WriteTimeout httpcore.NetworkError httpcore.ConnectError httpcore.ReadError httpcore.WriteError httpcore.ProtocolError httpcore.RemoteProtocolError httpcore.LocalProtocolError httpcore.ProxyError httpcore.UnsupportedProtocol","title":"API Reference"},{"location":"table-of-contents/#api-reference","text":"Quickstart httpcore.request() httpcore.stream() Requests, Responses, and URLs httpcore.Request httpcore.Response httpcore.URL Connection Pools httpcore.ConnectionPool Proxies httpcore.HTTPProxy Connections httpcore.HTTPConnection httpcore.HTTP11Connection httpcore.HTTP2Connection Async Support httpcore.AsyncConnectionPool httpcore.AsyncHTTPProxy httpcore.AsyncHTTPConnection httpcore.AsyncHTTP11Connection httpcore.AsyncHTTP2Connection Network Backends Sync httpcore.backends.sync.SyncBackend httpcore.backends.mock.MockBackend Async httpcore.backends.auto.AutoBackend httpcore.backends.asyncio.AsyncioBackend httpcore.backends.trio.TrioBackend httpcore.backends.mock.AsyncMockBackend Base interfaces httpcore.backends.base.NetworkBackend httpcore.backends.base.AsyncNetworkBackend Exceptions httpcore.TimeoutException httpcore.PoolTimeout httpcore.ConnectTimeout httpcore.ReadTimeout httpcore.WriteTimeout httpcore.NetworkError httpcore.ConnectError httpcore.ReadError httpcore.WriteError httpcore.ProtocolError httpcore.RemoteProtocolError httpcore.LocalProtocolError httpcore.ProxyError httpcore.UnsupportedProtocol","title":"API Reference"}]}